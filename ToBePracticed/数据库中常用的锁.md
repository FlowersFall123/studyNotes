# 数据库中常用的锁

## **1. 行级锁（Row Lock）**

作用：只锁某几行 → 并发好。

------

### **1.1 行共享锁（S 锁）**

👉 **多个事务可以同时读，但不能写。**

#### 📌 使用场景

- 只读，不想别人修改
- 比如：审核时必须读到一致的数据

#### 📌 SQL 写法

```
SELECT * FROM user WHERE id = 1 LOCK IN SHARE MODE;
```

#### 📌 效果

- 其他事务 **可以继续读**
- 但 **不能 UPDATE / DELETE** 这一行，会被阻塞

------

### **1.2 行排他锁（X 锁）——最常用**

👉 **我读的时候别人也不能读、不能写。**

#### 📌 使用场景：扣库存、抢单

必须保证只有一个线程操作这行。

#### 📌 SQL 写法（悲观锁）

```
SELECT * FROM product WHERE id = 1 FOR UPDATE;
```

#### 📌 效果

- 其他事务 **不能用 FOR UPDATE 访问同一行**
- 必须等这个事务提交

------

### **1.3 记录锁（Record Lock）**

👉 精确锁一条记录（等值条件）。

#### 📌 使用场景

- 主键 / 唯一索引 等值查询

#### 📌 SQL

```
SELECT * FROM user WHERE id = 1 FOR UPDATE;
```

它只锁 `id=1` 这一条，其他 id 不受影响。

------

### **1.4 间隙锁（Gap Lock）**

👉 锁住的是"范围之间的空隙"，不是行。
 👉 RR 隔离级别自动出现。

#### 📌 使用场景

- 防止别人插入新数据（避免幻读）
- 常用于范围查询

#### 📌 SQL（范围查询）

```
SELECT * FROM product WHERE price > 100 FOR UPDATE;
```

#### 📌 效果

别人不能执行：

```
INSERT INTO product(price) VALUES(150);
```

因为你锁了 "price > 100 这个范围的间隙"。

------

### **1.5 Next-Key Lock（记录锁 + 间隙锁）**

👉 InnoDB 在 RR 隔离级别的默认锁方式。
 👉 同时锁住“记录 + 范围”

### 📌 使用场景

- #### 范围查询时避免幻读

- 保证当前查询的一致性

#### 📌 SQL

```
SELECT * FROM product WHERE price BETWEEN 50 AND 100 FOR UPDATE;
```

效果：

- 锁住 50～100 之间已存在的记录
- 锁住这个范围的空隙
- 锁住边界两边的 gap

------

## **2. 表级锁（Table Lock）**

作用：锁整张表。简单粗暴、效率高、并发差。

------

### **2.1 表读锁（READ LOCK）**

👉 我读时别人不能写，但可以读。

#### 📌 使用场景

- 报表统计
- 需要全表一致性快照

#### 📌 SQL

```
LOCK TABLES product READ;

SELECT * FROM product;

UNLOCK TABLES;
```

------

### **2.2 表写锁（WRITE LOCK）**

👉 我写时别人 **不能读，不能写**。

#### 📌 使用场景

- 批量更新
- 大事务更新全表
- 需要严格一致性

#### 📌 SQL

```
LOCK TABLES product WRITE;

UPDATE product SET status = 1;

UNLOCK TABLES;
```

------

## **3. 意向锁（Intention Lock）**（MySQL 自动加）

你**不用写 SQL**，但必须理解。

包括：

- IS（意向共享锁）
- IX（意向排他锁）

### 📌 使用场景

**当你对某一行加行锁时，MySQL 会自动给表加意向锁。**

比如：

```
SELECT * FROM product WHERE id = 1 FOR UPDATE;
```

MySQL 自动做：

- 表：加 IX
- 行：加 X

作用：避免表锁与行锁之间的冲突。

你不需要写任何代码。

------

## **4. 元数据锁（MDL，Metadata Lock）**（自动加）

### 📌 你写 DDL（改结构）时会自动出现：

```
ALTER TABLE product ADD COLUMN tag varchar(20);
```

如果有事务正在访问 product 表 → ALTER 会被永久阻塞。

### 📌 使用场景

- 保护表结构安全
- 防止 DML / DDL 冲突

你仍然不需要写任何 SQL。

------

##  **5. 乐观锁（Optimistic Lock）**（最常用）

不是数据库锁，而是业务层“版本号”。

### 📌 场景

- 高并发（比如库存、余额）
- 不想排队等锁

### 📌 表结构

```
version int
```

### 📌 更新

```
UPDATE product
SET stock = stock - 1, version = version + 1
WHERE id = 1 AND version = 3;
```

如果更新条数 = 0 → 表示被别人抢先改了。

------

## 🎯 **完整简单总结表**

| 锁类型     | 什么时候用     | SQL 示例                                |
| ---------- | -------------- | --------------------------------------- |
| 行共享锁 S | 只读且不想被写 | `SELECT ... LOCK IN SHARE MODE`         |
| 行排他锁 X | 扣库存、抢单   | `SELECT ... FOR UPDATE`                 |
| 记录锁     | 索引等值查询   | `SELECT * FROM t WHERE id=1 FOR UPDATE` |
| 间隙锁     | 防止插入       | `SELECT ... WHERE price>100 FOR UPDATE` |
| Next-Key   | 范围查询       | `SELECT ... BETWEEN ... FOR UPDATE`     |
| 表读锁     | 全表统计       | `LOCK TABLES t READ`                    |
| 表写锁     | 批量更新       | `LOCK TABLES t WRITE`                   |
| 意向锁     | 自动           | 系统自动加                              |
| MDL 锁     | DDL            | 自动（ALTER TABLE 等）                  |
| 乐观锁     | 高并发更新     | `UPDATE ... WHERE version=?`            |