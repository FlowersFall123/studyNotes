# Redis 缓存三大问题笔记

------

## 1️⃣ 缓存穿透（Cache Penetration）

### 📌 1. 概念

查询一个 **数据库中根本不存在的数据**。

- Redis 中没有
- DB 中也没有
- 每次都直击数据库 → 压力巨大

#### 例子：

查询用户 ID = -1 或一个不存在的 ID，被恶意反复请求。

------

### 📌 2. 危害

- 数据库 QPS 被打爆
- 缓存命中率降低
- 系统性能下降

------

## 📌 3. 解决方案

#### ✔ 方案 1：缓存空值（最常用）

DB 查询不到 → 仍然写一个空对象到 Redis（短 TTL）

```
if (value == null) {
    redis.set(key, "NULL", 30); // 空值缓存
}
```

#### ✔ 方案 2：布隆过滤器（大规模使用）

提前把 **所有可能存在的 key** 放入布隆过滤器。
 请求时先判断“是否可能存在”，不存在直接拦截。

------

## 2️⃣ 缓存击穿（Cache Breakdown）

### 📌 1. 概念

**某一个热点 key 突然过期**，恰好有巨量请求同时查询它。

- 这个 key 过期瞬间 → 全部打到 DB → DB 崩溃

#### 类比：

一个明星资料的缓存刚过期，突然大量用户来查。

------

### 📌 2. 危害

- 对热点数据的同时请求全部击中数据库
- 数据库压力瞬间激增

------

### 📌 3. 解决方案

### ✔ 方案 1：分布式锁（最经典）

热点 key 过期时，只让 **一个线程** 去重建缓存，其它线程等待。

```
if (tryLock("lock:user:1")) {
    data = db.query(id);
    redis.set(id, data, 3600);
} else {
    Thread.sleep(50);
    return redis.get(id);
}
```

### ✔ 方案 2：逻辑过期（适合热点数据）

key 不真正过期，而是设置“过期时间字段”。
 返回旧数据，同时后台异步更新。

### ✔ 方案 3：热点 key 永不过期

后台定时更新，避免过期瞬间并发集中冲 DB。

------

## 3️⃣ 缓存雪崩（Cache Avalanche）

### 📌 1. 概念

**大量 key 同时失效** 或 Redis 整体故障→ 所有请求直击数据库。

#### 类比：

上百个明星的资料缓存一起过期 → 系统瞬间瘫痪。

------

### 📌 2. 危害

- Redis 命中率骤降
- 所有流量压到数据库
- 系统整体不可用

------

### 📌 3. 解决方案

### ✔ 方案 1：给 key 设置随机过期时间（最简单）

避免大量 key 同时到期。

```
redis.set(key, value, 3600 + random(600));
```

### ✔ 方案 2：热点数据永不过期 + 后台刷新

### ✔ 方案 3：多级缓存（如 Caffeine + Redis）

Redis 挂了也能抗住一部分流量。

### ✔ 方案 4：限流、降级

系统压力过高时，直接返回默认值或错误页。

------

## 🧠 三者区别总结

| 名称         | 触发原因          | 影响范围       | 解决方向             |
| ------------ | ----------------- | -------------- | -------------------- |
| **缓存穿透** | 查不存在的数据    | 全部落到 DB    | 缓存空值、布隆过滤器 |
| **缓存击穿** | 热点 key 突然过期 | 一个热点被打爆 | 分布式锁、逻辑过期   |
| **缓存雪崩** | 大量 key 同时过期 | 整个系统被打爆 | 随机 TTL、多级缓存   |

------

## 📌 面试版本一句话总结

- **穿透**：查不存在 → 空值缓存 or 布隆过滤器。
- **击穿**：热点 key 过期 → 分布式锁 or 逻辑过期。
- **雪崩**：大批 key 一起过期 → 随机过期时间 + 多级缓存 + 限流。