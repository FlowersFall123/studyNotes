# 苍穹外卖学习笔记

## Nginx

### **反向代理**配置方式：

```nginx
server {
    listen 80;
    server_name localhost;
    
    location /api/ {
        proxy_pass http://localhost:8080/admin;
    }
}
```

1. `listen 80` - 监听 80 端口（HTTP）
2. `server_name localhost` - 服务器名为 localhost
3. `location /api/ { ... }` - 定义如何处理以 `/api/` 开头的请求路径
4. `proxy_pass http://localhost:8080/admin` - 将匹配的请求转发到本机的 8080 端口的 `/admin` 路径

### **负载均衡**配置方式

```nginx

upstream webservers{
	server 192.168.100.128:8080;
	server 192.168.100.129:8080;
}
server{
	listen 80;
	server_name localhost;
	
	location /api/{
		proxy_pass:http://webservers/admin;//负载均衡
	}
}
```

- 定义了一个名为 `webservers` 的服务器组，包含两个后端服务器：
  - `192.168.100.128:8080`
  - `192.168.100.129:8080`

- 当访问 `http://localhost/api/xxx` 时，Nginx 会：
  1. 从 `webservers` 组中选择一个后端服务器（如 `192.168.100.128:8080`）。
  2. 将请求代理到 `http://192.168.100.128:8080/admin/xxx`。

### **负载均衡策略对比表**

| 策略             | 特点                        | 适用场景                          | 配置示例（Nginx）                                            |
| :--------------- | :-------------------------- | :-------------------------------- | :----------------------------------------------------------- |
| **轮询**         | 均匀分配，简单              | 无状态服务（如 REST API）         | `upstream backend { server 10.0.1.1; server 10.0.1.2; }`     |
| **加权轮询**     | 按权重分配流量              | 服务器性能不均（如 CPU/内存差异） | `upstream backend { server 10.0.1.1 weight=3; server 10.0.1.2 weight=1; }` |
| **IP 哈希**      | 固定客户端到服务器          | 会话保持（如购物车、登录状态）    | `upstream backend { ip_hash; server 10.0.1.1; server 10.0.1.2; }` |
| **最少连接**     | 动态平衡连接数              | 长连接服务（如 WebSocket）        | `upstream backend { least_conn; server 10.0.1.1; server 10.0.1.2; }` |
| **响应时间优先** | 优化延迟（Nginx Plus 专属） | 支付网关、实时交易                | `upstream backend { least_time header; server 10.0.1.1; server 10.0.1.2; }` |
| **一致性哈希**   | 减少缓存抖动                | 缓存服务器（如 Redis、CDN）       | `upstream backend { consistent_hash $request_uri; server 10.0.1.1; server 10.0.1.2; }` |
| **随机**         | 无规则分配                  | 测试或简单场景                    | `upstream backend { random; server 10.0.1.1; server 10.0.1.2; }` |

## 加密操作

### TODO使用

![](F:\苍穹外卖\图片\TODO使用.png)

### **密码加密：**

```xml
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-crypto</artifactId>
    <version>5.7.3</version> <!-- 使用最新版本 -->
</dependency>
```

```java
String hashedPassword = BCrypt.hashpw(password, BCrypt.gensalt());
```

- **`BCrypt.gensalt()`**
  - 生成一个**随机的盐值（Salt）**（类似于加密的“调味料”）。
  - 盐值的作用：**即使两个用户密码相同，加密后的结果也不同**，防止黑客用彩虹表破解。
  - 示例输出：`$2a$10$N9qo8uLOickgx2ZMRZoMy...`（包含算法版本、成本因子和随机盐）。
- **`BCrypt.hashpw(password, salt)`**
  - 将用户的明文密码（`password`）和盐值一起加密，生成**不可逆的哈希值**。
  - 示例输出：`$2a$10$N9qo8uLOickgx2ZMRZoMy.I4hr.fJ4V8T1jXm2a5n7ZHDGFjQY/GO`（包含盐+哈希结果）。

```java
boolean isMatch = BCrypt.checkpw(rawPassword, hashedPassword);
```

- **内部逻辑**：
  1. 从`hashedPassword`中提取**盐值**（因为哈希值里已经包含了盐）。
  2. 用同样的盐值对用户输入的密码加密，生成临时哈希值。
  3. 比较临时哈希值和数据库存储的哈希值是否一致。
- 返回 `true`（密码正确）或 `false`（密码错误）。

## 静态资源

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurationSupport {
    
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 映射本地文件系统路径
        registry.addResourceHandler("/files/**")
                .addResourceLocations("file:D:/uploads/");
        
        // 映射类路径下的静态资源
        registry.addResourceHandler("/static/**")
                .addResourceLocations("classpath:/static/");
        
        // 多个资源位置
        registry.addResourceHandler("/assets/**")
                .addResourceLocations("classpath:/assets/", "file:/opt/assets/");
    }
}
```

- **资源处理器**：`/static/**` 匹配以 `/static/` 开头的 URL
- **资源位置**：`classpath:/static/` 表示类路径下的 static 目录
  - `classpath:` 前缀表示从 classpath（编译后的 resources 目录）查找
  - 这是 Spring Boot 默认的静态资源位置之一

## 接口文档

### 常用注解

| 注解名称                | 作用位置                | 用途说明                            | 常用属性示例                                                 |
| :---------------------- | :---------------------- | :---------------------------------- | :----------------------------------------------------------- |
| **`@Api`**              | **Controller 类**上方   | 标注整个Controller类的描述信息      | `value="用户接口"`, `tags={"用户管理"}`, `description="用户相关操作接口"` |
| **`@ApiOperation`**     | **Controller 方法**上方 | 描述单个接口的功能和细节            | `value="创建用户"`, `notes="需提供用户名和密码"`, `response=User.class` |
| **`@ApiModel`**         | **实体类/DTO类**上方    | 标注模型类的说明（用于请求/响应体） | `value="用户模型"`, `description="用户基本信息"`             |
| **`@ApiModelProperty`** | **实体类字段**上方      | 描述模型类中每个字段的属性和约束    | `value="用户名"`, `example="admin"`, `required=true`, `dataType="string"` |

### **详细解释及示例**

#### 1. `@Api` (类级别)

```java
@Api(tags = "用户管理", description = "用户相关操作接口")
@RestController
@RequestMapping("/users")
public class UserController {
    // ...
}
```

**作用**：定义Controller在Swagger文档中的分组和描述。

------

#### 2. `@ApiOperation` (方法级别)

```java
@ApiOperation(value = "创建用户", notes = "需提供用户名和密码", response = User.class)
@PostMapping
public User createUser(@RequestBody User user) {
    // ...
}
```

**作用**：描述接口功能、注意事项和返回类型。

------

#### 3. `@ApiModel` + `@ApiModelProperty` (模型类)

```java
@ApiModel(value = "用户模型", description = "用户基本信息")
public class User {
    @ApiModelProperty(value = "用户名", example = "admin", required = true)
    private String username;
    
    @ApiModelProperty(value = "密码", example = "123456", required = true)
    private String password;
}
```

**作用**：

- `@ApiModel`：定义模型类在文档中的名称和描述。
- `@ApiModelProperty`：定义字段的详细属性（如是否必填、示例值等）。

![](F:\苍穹外卖\图片\接口文档.png)

## 属性拷贝

### **核心前提**

1. **属性名必须一致**
   - 例如 `EmployeeDTO` 的 `username` 会自动拷贝到 `Employee` 的 `username`。
   - 如果目标对象没有同名属性（如 `EmployeeDTO` 没有 `password` 字段），则该字段会被忽略。
2. **类型兼容性**
   - 属性类型必须兼容（相同类型，或可自动转换的类型，如 `String` → `Integer`）。
   - 如果类型不匹配（如 `String` 拷贝到 `LocalDateTime`），会抛出异常或赋值为 `null`（取决于工具）。

### 实体类注解

| 注解                  | 作用                                                         | 等效的手写代码示例                                           |
| :-------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| `@Data`               | **综合注解**，自动生成： - getter/setter - `equals()`/`hashCode()` - `toString()` | 手动为所有字段编写上述方法                                   |
| `@Builder`            | 提供**建造者模式**的链式构造方式                             | `Employee.builder().id(1L).name("张三").build()`             |
| `@NoArgsConstructor`  | 生成**无参构造方法**                                         | `public Employee() {}`                                       |
| `@AllArgsConstructor` | 生成**全参构造方法**（所有字段作为参数）                     | `public Employee(Long id, String username, ..., Long updateUser) { /*...*/ }` |

```java
public Employee convertToEmployee(EmployeeDTO dto) {
    Employee employee = new Employee();
    
    // 1. 基础属性拷贝（同名且类型兼容的字段）
    BeanUtils.copyProperties(dto, employee);
    
    // 2. 处理特殊字段（属性名或类型不匹配）
    employee.setStatus(1); // 默认状态
    employee.setPassword(BCrypt.hashpw(PasswordConstant.DEFAULT_PASSWORD, BCrypt.gensalt()));//密码加密
    
    // 3. 忽略不需要拷贝的字段（如自动生成的 createTime）
    LocalDateTime now = LocalDateTime.now();
    employee.setCreateTime(now);
    employee.setUpdateTime(now);
    
    return employee;
}
```

## JWT验证

## 1. Token 生成流程

```java
public static String createJWT(String secretKey, long ttlMillis, Map<String, Object> claims) {
    // 指定签名的时候使用的签名算法，也就是header那部分
    SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;

    // 生成JWT的时间
    long expMillis = System.currentTimeMillis() + ttlMillis;
    Date exp = new Date(expMillis);

    // 设置jwt的body
    JwtBuilder builder = Jwts.builder()
            // 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的
            .setClaims(claims)
            // 设置签名使用的签名算法和签名使用的秘钥
            .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))
            // 设置过期时间
            .setExpiration(exp);

    return builder.compact();
}
```

```java
// 登录成功后，生成jwt令牌
Map<String, Object> claims = new HashMap<>();
claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
String token = JwtUtil.createJWT(
        jwtProperties.getAdminSecretKey(),
        jwtProperties.getAdminTtl(),
        claims);
```

- **作用**：用户登录成功后生成JWT令牌
- **步骤**：
  1. 创建claims Map，存储需要放入Token中的信息（如员工ID）
  2. 调用JwtUtil.createJWT方法生成Token
  3. 参数说明：
     - `adminSecretKey`：JWT签名密钥
     - `adminTtl`：Token有效期
     - `claims`：要存储的自定义数据

## 2. Token 校验流程

```java
public static Claims parseJWT(String secretKey, String token) {
    // 得到DefaultJwtParser
    Claims claims = Jwts.parser()
            // 设置签名的秘钥
            .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))
            // 设置需要解析的jwt
            .parseClaimsJws(token).getBody();
    return claims;
}
```

```java
log.info("jwt校验:{}", token);
Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
```

- **验证过程**：
  1. **签名验证**：使用相同的`adminSecretKey`验证Token签名，确保未被篡改
  2. **解析Token**：签名验证通过后，解码Token的Payload部分
  3. **获取数据**：从Claims对象中提取存储的用户数据（如员工ID）

## 3. ThreadLocal存储机制

```java
public class BaseContext {
    public static ThreadLocal<Long> threadLocal = new ThreadLocal<>();

    public static void setCurrentId(Long id) {
        threadLocal.set(id);
    }

    public static Long getCurrentId() {
        return threadLocal.get();
    }

    public static void removeCurrentId() {
        threadLocal.remove();
    }
}
```

```java
BaseContext.setCurrentId(empId);
```

- **作用**：将用户信息存储在线程局部变量中，实现请求级别的数据共享
- **特点**：
  - 线程安全：每个线程有自己独立的副本
  - 无需显式传递：在Service层、Mapper层可直接获取

## 分页查询

### 1. 添加分页依赖

首先在pom.xml中添加PageHelper分页插件依赖：

```xml
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper-spring-boot-starter</artifactId>
</dependency>
```

### 2. 配置MyBatis

在application.yml中配置MyBatis：

```yml
mybatis:
  mapper-locations: classpath:mapper/*.xml
```

### 3. 创建Mapper XML文件

在resources/mapper目录下创建EmployeeMapper.xml：

注意：需要有**MyBatisX**的插件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >
<mapper namespace="com.sky.mapper.EmployeeMapper">
    <select id="pageQuery" resultType="com.sky.entity.Employee">
        select * from employee
        <where>
            <if test="name!=null and name!=''">
                and name like concate('%',#{name},'%')
            </if>
        </where>
        order by create_time desc
    </select>
</mapper>
```

1. **`<select id="pageQuery" resultType="com.sky.entity.Employee">`**
   - 这是一个查询语句的声明
   - `id="pageQuery"`：对应Mapper接口中的方法名
   - `resultType="com.sky.entity.Employee"`：查询结果会自动映射到这个实体类
2. **`SELECT * FROM employee`**
   - 基础SQL语句：从employee表查询所有字段
3. **`<where>`标签**
   - MyBatis的动态SQL标签
   - 作用：智能处理WHERE子句
   - 特性：
     - 只有当包含的条件有内容时，才会插入WHERE关键字
     - 会自动去除开头多余的AND或OR
4. **`<if test="name != null and name != ''">`**
   - 条件判断标签
   - `test`属性中的**表达式为true时**，包含的SQL会**生效**
   - 这里判断：当name参数不为null且不是空字符串时
5. **`AND name LIKE CONCAT('%', #{name}, '%')`**
   - 模糊查询条件
   - `CONCAT`函数：拼接字符串（注意MySQL中是CONCAT，不是CONCATE）
   - `#{name}`：MyBatis的参数占位符，会替换为实际参数值
   - 效果：搜索包含该名字的员工（前后模糊匹配）
6. **`</where>`**
   - 结束where标签
7. **`ORDER BY create_time DESC`**
   - 结果排序：按创建时间降序排列（最新的在前）

### 4. Service层实现

```java
@Override
public PageResult pageQuery(EmployeePageQueryDTO employeePageQueryDTO) {
    // 1. 设置分页参数
    PageHelper.startPage(
        employeePageQueryDTO.getPage(), 
        employeePageQueryDTO.getPageSize()
    );
    
    // 2. 执行分页查询
    Page<Employee> page = employeeMapper.pageQuery(employeePageQueryDTO);
    
    // 3. 封装返回结果
    return new PageResult(
        page.getTotal(),    // 总记录数
        page.getResult()    // 当前页数据列表
    );
```

## 时间格式转换

### 1. 使用 `@JsonFormat` 注解方式

在实体类字段上直接指定格式：

```java
@JsonFormat(pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime createTime;
```

### 2. 全局配置方式（自定义 Jackson 对象映射器）

#### 2.1 创建自定义 JacksonObjectMapper

```java
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    //public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}
```

#### 2.2 配置 WebMvc 扩展消息转换器

```java
@Configuration
@Slf4j
public class WebMvcConfiguration extends WebMvcConfigurationSupport {
    
    /**
     * 扩展Spring MVC框架的消息转换器
     * @param converters
     */
    @Override
    protected void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
        //创建一个消息转换器对象
        MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        //需要为消息转换器设置一个对象转换器，对象转换器可以将Java对象序列化为json数据
        converter.setObjectMapper(new JacksonObjectMapper());
        //将消息转换器对象添加到消息转换器集合中
        converters.add(0,converter);
    }
}
```

## 公共字段自动填充机制

### 1. 自定义注解 `@AutoFill`

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill {
    //数据库操作类型：UPDATE、INSERT
    OperationType value();
}
```

- `@Target(ElementType.METHOD)`：限制这个注解只能用在方法上，不能用在类或字段上
- `@Retention(RetentionPolicy.RUNTIME)`：表示这个注解在程序运行时仍然存在，这样我们才能通过反射读取它
- `OperationType value()`：定义了一个属性，使用时需要指定操作类型(INSERT或UPDATE)

### 2. 操作类型枚举 `OperationType`

```java
/**
 * 数据库操作类型
 */
public enum OperationType {

    /**
     * 更新操作
     */
    UPDATE,

    /**
     * 插入操作
     */
    INSERT

}
```

**作用**：定义两种数据库操作类型，用于区分是新增数据还是修改数据。

### 3. 切面实现 `AutoFillAspect`

```java
@Aspect
@Component
@Slf4j
public class AutoFillAspect {
    /**
     * 切入点
     */
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
    public void autoFillPointCut(){}

    /**
     * 前置通知，在通知中进行公共字段的赋值
     */
    @Before("autoFillPointCut()")  // 在切入点方法执行前执行
    public void autoFill(JoinPoint joinPoint) throws Exception {
        log.info("开始自动填充公共字段...");

        // 1. 获取到当前被拦截的方法上的数据库操作类型
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();//方法签名对象
        AutoFill autoFill = signature.getMethod().getAnnotation(AutoFill.class);//获取方法上的注解对象
        OperationType operationType = autoFill.value();//获取注解对象中的操作类型

        // 2. 获取方法参数（实体对象）
        Object[] args = joinPoint.getArgs();
        if (args == null || args.length == 0) return;
        Object entity = args[0];

        // 3. 准备要填充的数据
        LocalDateTime now = LocalDateTime.now();  // 当前时间
        Long currentId = BaseContext.getCurrentId(); // 当前用户ID

        // 4. 根据操作类型填充不同字段
        if (operationType == OperationType.INSERT) {
            // 插入操作需要设置所有公共字段
            setField(entity, AutoFillConstant.SET_CREATE_TIME, now);
            setField(entity, AutoFillConstant.SET_CREATE_USER, currentId);
            setField(entity, AutoFillConstant.SET_UPDATE_TIME, now);
            setField(entity, AutoFillConstant.SET_UPDATE_USER, currentId);
        } else if (operationType == OperationType.UPDATE) {
            // 更新操作只需要设置更新相关字段
            setField(entity, AutoFillConstant.SET_UPDATE_TIME, now);
            setField(entity, AutoFillConstant.SET_UPDATE_USER, currentId);
        }
    }

    private void setField(Object obj, String methodName, Object value) throws Exception {
        // 获取对象的指定方法
        Method method = obj.getClass().getDeclaredMethod(methodName, value.getClass());
        // 调用方法设置值
        method.invoke(obj, value);
    }
}
```

- `@Pointcut`：定义切入点表达式，这里的意思是：
  - `execution(* com.sky.mapper.*.*(..))`：拦截com.sky.mapper包下的所有类的所有方法
  - `&& @annotation(com.sky.annotation.AutoFill)`：并且这些方法上要有@AutoFill注解
- `autoFillPointCut()`：给这个切入点起个名字，后面通知会引用它
- **获取方法信息**：
  - `joinPoint.getSignature()` 获取方法签名
  - 转换为`MethodSignature`后可以获取更多方法信息
  - `getAnnotation(AutoFill.class)` 获取方法上的@AutoFill注解
  - `autoFill.value()` 获取注解中指定的操作类型
- **获取实体对象**：
  - `joinPoint.getArgs()` 获取方法的所有参数
  - 约定第一个参数就是要操作的实体对象
- **准备数据**：
  - `LocalDateTime.now()` 获取当前时间
  - `BaseContext.getCurrentId()` 获取当前用户ID（通常从线程局部变量或安全上下文中获取）

```java
private void setField(Object obj, String methodName, Object value) throws Exception {
    // 获取对象的指定方法
    Method method = obj.getClass().getDeclaredMethod(methodName, value.getClass());
   // 调用方法设置值
    method.invoke(obj, value);
}
```

- **反射设置字段**：
  - 根据操作类型决定设置哪些字段
  - INSERT操作设置所有四个字段
  - UPDATE操作只设置最后两个字段
  - `getDeclaredMethod()`：通过反射获取对象的方法
    - 参数1：方法名（如"setCreateTime"）
    - 参数2：方法参数类型（如LocalDateTime.class）
  - `method.invoke()`：调用这个方法
    - 参数1：要调用方法的对象
    - 参数2：要传入的参数值

### 4.使用方式

```java
@AutoFill(value = OperationType.UPDATE)
void update(Category category);
```

1. 当你调用`update(category)`方法时：
   - 切面会先拦截这个调用
   - 发现是UPDATE操作，自动设置updateTime和updateUser字段
   - 然后才执行真正的update方法
2. 当你调用`insert(category)`方法时：
   - 切面拦截后，发现是INSERT操作
   - 自动设置所有四个公共字段
   - 然后执行真正的insert方法

## 数据库批量操作

#### **1. 批量插入**

```xml
<insert id="insertBatch">
    INSERT INTO dish_flavor (dish_id, name, value)
    VALUES
    <foreach collection="flavorList" item="df" separator=",">
        (#{df.dishId}, #{df.name}, #{df.value})
    </foreach>
</insert>
```

- **作用**：一次性插入多条 `dish_flavor` 记录。

- **参数**：`flavorList`（List 集合，每个元素包含 `dishId`、`name`、`value`）。

- **SQL 生成示例**：

  ```sql
  INSERT INTO dish_flavor (dish_id, name, value) 
  VALUES (1, '辣度', '微辣'), (1, '甜度', '少糖'), (2, '温度', '常温');
  ```

------

#### **2. 批量删除**

```xml
<delete id="deleteBatch">
    DELETE FROM dish_flavor 
    WHERE dish_id IN
    <foreach collection="ids" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</delete>
```

- **作用**：根据 `dish_id` 批量删除 `dish_flavor` 记录。

- **参数**：`ids`（List 或 Array，存放要删除的 `dish_id` 集合）。

- **SQL 生成示例**：

  ```sql
  DELETE FROM dish_flavor WHERE dish_id IN (1, 2, 3);
  ```

------

#### **3. 批量查询**

```xml
<select id="getSetMealIdsByDishIds" resultType="java.lang.Long">
    SELECT setmeal_id FROM setmeal_dish 
    WHERE dish_id IN
    <foreach collection="dishIds" item="id" open="(" separator="," close=")">
        #{id}
    </foreach>
</select>
```

- **作用**：根据 `dish_id` 批量查询关联的 `setmeal_id`。

- **参数**：`dishIds`（List 或 Array，存放要查询的 `dish_id` 集合）。

- **SQL 生成示例**：

  ```sql
  SELECT setmeal_id FROM setmeal_dish WHERE dish_id IN (1, 2, 3);
  ```

## Redis常用命令

### 字符串操作命令

1. **SET key value** - 设置键值
2. **GET key** - 获取值
3. **DEL key** - 删除键
4. **SETEX key seconds value** - 设置值+过期时间(秒)
5. **SETNX key value** - 仅当键不存在时设置(实现锁)

### 哈希操作命令

1. **HSET key field value** - 设置哈希表中字段的值
2. **HGET key field** - 获取哈希表中字段的值
3. **HDEL key field1 field2 ...** - 删除哈希表中的一个或多个字段
4. **HKEYS key** - 获取哈希表中所有字段名
5. **HVALS key** - 获取哈希表中所有值

### 列表操作命令

1. **LPUSH key value [value ...]** - 将一个或多个值插入到列表头部
2. **LRANGE key start stop** - 获取列表指定范围内的元素
3. **RPOP key** - 移除并获取列表的最后一个元素
4. **LLEN key** - 获取列表长度

### 集合操作命令

1. **SADD key member [member ...]** - 向集合添加一个或多个成员
2. **SMEMBERS key** - 返回集合中的所有成员
3. **SCARD key** - 获取集合的成员数
4. **SINTER key [key ...]** - 返回多个集合的交集
5. **SUNION key [key ...]** - 返回多个集合的并集
6. **SREM key member [member ...]** - 移除集合中一个或多个成员

### 有序集合操作命令

1. **ZADD key  score member [score member ...]** - 向有序集合添加一个或多个成员，或更新已存在成员的分数
2. **ZRANGE key start stop [WITHSCORES]** - 通过索引区间返回有序集合指定区间内的成员（升序）
3. **ZINCRBY key increment member** - 有序集合中对指定成员的分数加上增量
4. **ZREM key member [member ...]** - 移除有序集合中的一个或多个成员

### 通用命令

1. **KEYS pattern** - 查找所有符合给定模式的key
2. **EXISTS key [key ...]** - 检查key是否存在
3. **TYPE key** - 返回key所存储的值的类型
4. **DEL key [key ...]** - 删除一个或多个key

## Redis在Java中的使用

### 环境配置

#### 1. 添加依赖

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

### 2. 配置文件

```yml
spring:
  redis:
    host: localhost
    port: 6379
    database: 0
```

### Redis操作API

#### 1. 字符串(String)操作

```java
@Autowired
private StringRedisTemplate redisTemplate;

// 基本操作
redisTemplate.opsForValue().set("key123", "haha");
String value = redisTemplate.opsForValue().get("key");

// 带过期时间的设置
redisTemplate.opsForValue().set("code", "123456", 60, TimeUnit.SECONDS);

// 原子性操作
redisTemplate.opsForValue().setIfAbsent("lock", "123");  // 成功返回true
redisTemplate.opsForValue().setIfAbsent("lock", "222");  // 失败返回false
```

#### 2. 哈希(Hash)操作

```java
// 添加/修改字段
redisTemplate.opsForHash().put("user", "name", "张三");
redisTemplate.opsForHash().put("user", "age", "18");

// 获取字段值
String name = (String) redisTemplate.opsForHash().get("user", "name");

// 获取所有字段名
Set<Object> keys = redisTemplate.opsForHash().keys("user");

// 获取所有字段值
List<Object> values = redisTemplate.opsForHash().values("user");

// 删除字段
redisTemplate.opsForHash().delete("user", "name");
```

#### 3. 列表(List)操作

```java
// 批量左插入
redisTemplate.opsForList().leftPushAll("list", "a", "b", "c");

// 单条左插入
redisTemplate.opsForList().leftPush("list", "d");

// 获取范围元素
List<String> list = redisTemplate.opsForList().range("list", 0, -1);

// 右弹出元素
redisTemplate.opsForList().rightPop("list");

// 获取列表长度
Long size = redisTemplate.opsForList().size("list");
```

#### 4. 集合(Set)操作

```java
// 添加元素
redisTemplate.opsForSet().add("set1", "a", "b", "c", "d");
redisTemplate.opsForSet().add("set2", "c", "d", "e", "f");

// 获取所有元素
Set<String> set1 = redisTemplate.opsForSet().members("set1");

// 获取集合大小
Long size = redisTemplate.opsForSet().size("set1");

// 集合交集
Set<String> intersect = redisTemplate.opsForSet().intersect("set1", "set2");

// 集合并集
Set<String> union = redisTemplate.opsForSet().union("set1", "set2");

// 删除元素
redisTemplate.opsForSet().remove("set1", "a");
```

#### 5. 有序集合(ZSet)操作

```java
// 添加元素(带分数)
redisTemplate.opsForZSet().add("zset1", "a", 1);
redisTemplate.opsForZSet().add("zset1", "b", 2);
redisTemplate.opsForZSet().add("zset1", "c", 3);

// 获取范围元素
Set<String> zset1 = redisTemplate.opsForZSet().range("zset1", 0, -1);

// 增加元素分数
redisTemplate.opsForZSet().incrementScore("zset1", "a", 1);

// 删除元素
redisTemplate.opsForZSet().remove("zset1", "a", "b");
```

#### 6. 通用操作

```java
// 获取所有键
Set<String> keys = redisTemplate.keys("*");

// 检查键是否存在
Boolean exists = redisTemplate.hasKey("name");

// 获取键的类型
if (keys != null) {
    for(String key : keys) {
        DataType type = redisTemplate.type(key);
    }
}

// 删除键
redisTemplate.delete("list");
```

## HttpClient

### 依赖配置

首先需要在项目中添加 HttpClient 的依赖：

```xml
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
    <version>4.5.13</version>
</dependency>
```

### GET 请求示例

```java
public void testGet() throws IOException {
    // 1. 创建HttpClient对象
    CloseableHttpClient httpClient = HttpClients.createDefault();

    // 2. 创建HttpGet请求对象，指定URL
    HttpGet httpGet = new HttpGet("http://localhost:8080/user/shop/status");

    // 3. 执行请求，获取响应
    CloseableHttpResponse response = httpClient.execute(httpGet);

    // 4. 获取响应状态码
    int statusCode = response.getStatusLine().getStatusCode();
    System.out.println("服务端返回的状态码为： " + statusCode);

    // 5. 获取响应内容
    HttpEntity entity = response.getEntity();
    String body = EntityUtils.toString(entity);
    System.out.println("服务端返回的内容为： " + body);

    // 6. 关闭资源
    response.close();
    httpClient.close();
}
```

#### GET 请求步骤解析：

1. 创建 `CloseableHttpClient` 实例（HTTP客户端）
2. 创建 `HttpGet` 请求对象，设置请求URL
3. 执行请求，获取 `CloseableHttpResponse` 响应对象
4. 从响应中获取状态码
5. 从响应实体中获取响应内容
6. 关闭响应和客户端，释放资源

### POST 请求示例

```java
public void testPost() throws IOException {
    // 1. 创建HttpClient对象
    CloseableHttpClient httpClient = HttpClients.createDefault();

    // 2. 创建HttpPost请求对象，指定URL
    HttpPost httpPost = new HttpPost("http://localhost:8080/admin/employee/login");

    // 3. 准备请求参数（JSON格式）
    JSONObject json = new JSONObject();
    json.put("username", "admin");
    json.put("password", "123456");

    // 4. 创建请求实体并设置编码和内容类型
    StringEntity entity = new StringEntity(json.toString());
    entity.setContentEncoding("UTF-8");  // 设置编码
    entity.setContentType("application/json");  // 设置内容类型
    httpPost.setEntity(entity);  // 将实体设置到请求中

    // 5. 执行请求，获取响应
    CloseableHttpResponse response = httpClient.execute(httpPost);

    // 6. 获取响应状态码
    int statusCode = response.getStatusLine().getStatusCode();
    System.out.println("响应码为： " + statusCode);

    // 7. 获取响应内容
    HttpEntity httpEntity = response.getEntity();
    String body = EntityUtils.toString(httpEntity);
    System.out.println("响应数据为： " + body);

    // 8. 关闭资源
    response.close();
    httpClient.close();
}
```

#### POST 请求步骤解析：

1. 创建 `CloseableHttpClient` 实例
2. 创建 `HttpPost` 请求对象，设置请求URL
3. 准备请求参数（这里使用JSON格式）
4. 创建请求实体，设置编码和内容类型，并将实体添加到请求中
5. 执行请求，获取响应对象
6. 从响应中获取状态码
7. 从响应实体中获取响应内容
8. 关闭响应和客户端，释放资源

### 封装Get/Post

```java
public class HttpClientUtil {

    static final  int TIMEOUT_MSEC = 5 * 1000;

    /**
     * 发送GET方式请求
     * @param url
     * @param paramMap
     * @return
     */
    public static String doGet(String url,Map<String,String> paramMap){
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();

        String result = "";
        CloseableHttpResponse response = null;

        try{
            URIBuilder builder = new URIBuilder(url);
            if(paramMap != null){
                for (String key : paramMap.keySet()) {
                    builder.addParameter(key,paramMap.get(key));
                }
            }
            URI uri = builder.build();

            //创建GET请求
            HttpGet httpGet = new HttpGet(uri);

            //发送请求
            response = httpClient.execute(httpGet);

            //判断响应状态
            if(response.getStatusLine().getStatusCode() == 200){
                result = EntityUtils.toString(response.getEntity(),"UTF-8");
            }
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            try {
                response.close();
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return result;
    }

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost(String url, Map<String, String> paramMap) throws IOException {
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = "";

        try {
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            // 创建参数列表
            if (paramMap != null) {
                List<NameValuePair> paramList = new ArrayList();
                for (Map.Entry<String, String> param : paramMap.entrySet()) {
                    paramList.add(new BasicNameValuePair(param.getKey(), param.getValue()));
                }
                // 模拟表单
                UrlEncodedFormEntity entity = new UrlEncodedFormEntity(paramList);
                httpPost.setEntity(entity);
            }

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), "UTF-8");
        } catch (Exception e) {
            throw e;
        } finally {
            try {
                response.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return resultString;
    }

    /**
     * 发送POST方式请求
     * @param url
     * @param paramMap
     * @return
     * @throws IOException
     */
    public static String doPost4Json(String url, Map<String, String> paramMap) throws IOException {
        // 创建Httpclient对象
        CloseableHttpClient httpClient = HttpClients.createDefault();
        CloseableHttpResponse response = null;
        String resultString = "";

        try {
            // 创建Http Post请求
            HttpPost httpPost = new HttpPost(url);

            if (paramMap != null) {
                //构造json格式数据
                JSONObject jsonObject = new JSONObject();
                for (Map.Entry<String, String> param : paramMap.entrySet()) {
                    jsonObject.put(param.getKey(),param.getValue());
                }
                StringEntity entity = new StringEntity(jsonObject.toString(),"utf-8");
                //设置请求编码
                entity.setContentEncoding("utf-8");
                //设置数据类型
                entity.setContentType("application/json");
                httpPost.setEntity(entity);
            }

            httpPost.setConfig(builderRequestConfig());

            // 执行http请求
            response = httpClient.execute(httpPost);

            resultString = EntityUtils.toString(response.getEntity(), "UTF-8");
        } catch (Exception e) {
            throw e;
        } finally {
            try {
                response.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        return resultString;
    }
    private static RequestConfig builderRequestConfig() {
        return RequestConfig.custom()
                .setConnectTimeout(TIMEOUT_MSEC)
                .setConnectionRequestTimeout(TIMEOUT_MSEC)
                .setSocketTimeout(TIMEOUT_MSEC).build();
    }

}
```

## 微信小程序

### 注册小程序

1. 访问[微信公众平台](https://mp.weixin.qq.com/wxamp/home/guide?token=94164745&lang=zh_CN)
2. 点击"立即注册"，选择"小程序"类型
3. 按照指引填写邮箱、密码等信息完成注册

### 下载开发者工具

1. 前往[微信开发者工具下载页面](https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html)
2. 根据你的操作系统(Windows/Mac)下载对应版本
3. 安装开发者工具

### 创建小程序项目

1. 打开微信开发者工具
2. 点击"新建项目"
3. 填写项目信息：
   - 项目名称
   - 目录(选择或创建项目文件夹)
   - AppID(使用注册的小程序AppID)
   - 选择"小程序"项目类型

![](F:\苍穹外卖\图片\小程序.png)



## Spring Cache

### 一、核心概念

Spring Cache 是 Spring 框架提供的缓存抽象层，它提供统一的缓存操作接口，底层可以集成不同的缓存实现（如 Redis、EhCache、Caffeine 等）。

### 二、基本配置

#### 1. 依赖引入

```xml
<!-- Spring Cache 核心依赖 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-cache</artifactId>
</dependency>

<!-- Redis 实现（示例） -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

#### 2. 启用缓存

```java
@SpringBootApplication
@EnableCaching  // 关键注解：启用缓存功能
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

### 三、核心注解详解

#### 1. `@Cacheable`

**作用**：方法结果缓存

**执行流程**：

1. 检查缓存是否存在
2. 存在 → 直接返回缓存结果
3. 不存在 → 执行方法 → 缓存结果 → 返回结果

**常用属性**：

- `value/cacheNames`：缓存名称
- `key`：缓存键（SpEL 表达式）

**示例**：

```java
@Cacheable(value = "users", key = "#id)
public User getUserById(Long id) {
    return userRepository.findById(id).orElse(null);
}
```

#### 2. `@CachePut`

**作用**：强制更新缓存

**执行流程**：

1. 总是执行方法
2. 将结果存入缓存

**示例**：

```java
@CachePut(cacheNames = "userCache",key = "#user.id")//生成的key为userCache::id（#user.id是动态的值,从传入的参数里面获取的）
//    @CachePut(cacheNames = "userCache",key = "#result.id")//从这个方法的返回值里面获取id
//    @CachePut(cacheNames = "userCache",key = "#p0.id")//从传入的第一个参数里面获取id(p0与a0效果一样)
public User updateUser(User user) {
    return userRepository.save(user);
}
```

#### 3. `@CacheEvict`

**作用**：清除缓存

**常用属性**：

- `allEntries`：是否清空整个缓存区（默认 false）
- `beforeInvocation`：是否在方法执行前清除（默认 false）

**示例**：

```java
// 清除单个缓存
@CacheEvict(value = "users", key = "#id")
public void deleteUser(Long id) {
    userRepository.deleteById(id);
}

// 清空整个缓存区
@CacheEvict(value = "users", allEntries = true)
public void clearAllUserCache() {
    // 无需实现，注解已处理
}
```

## **Cpolar 内网穿透** 

### **1. 基本概念**

**内网穿透**（NAT 穿透）是一种**让外部网络访问内网服务的技术**。由于大多数本地网络使用 NAT，内网设备没有独立公网 IP，无法直接被外网访问。Cpolar 通过建立隧道，将内网服务映射到公网地址。

### **2. 核心功能**

- **HTTP/HTTPS 映射**：将本地 Web 服务（如 `localhost:8080`）暴露到公网（如 `xxxx.cpolar.top`）
- **TCP/UDP 穿透**：支持非 HTTP 协议（SSH、数据库等）
- **随机免费域名**（适合临时测试）
- **Web 管理面板**（默认 `127.0.0.1:4042`）
- **多平台支持**（Win/macOS/Linux/树莓派）

### **3. 基础使用命令**

#### **(1) 设置认证 Token**

```
cpolar.exe authtoken [官网获取的token]  # 认证账户
```

#### **(2) 启动 HTTP 穿透**

```
cpolar.exe http 8080  # 映射本地 8080 端口
```

### **4. 运行状态解读**

```
Tunnel Status       online          # 隧道状态（online 表示运行中）
Account             Free Plan       # 账户类型（免费版）
Web Interface       127.0.0.1:4042  # 本地管理界面
Forwarding          http://xxxx.cpolar.top -> http://localhost:8080  # 公网访问地址
# Conn              0              # 当前连接数
```



## Spring Task 定时任务

### 1. 概述

Spring Task 是 Spring 框架提供的轻量级定时任务调度工具，可以方便地在 Spring 应用中实现定时任务功能。

### 2. 基本使用

#### 2.1 添加依赖

在 Spring Boot 项目中，只需要添加 Spring Boot Starter 依赖即可：

```
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
</dependency>
```

#### 2.2 启用定时任务

在启动类或配置类上添加 `@EnableScheduling` 注解：

```
@SpringBootApplication
@EnableScheduling
public class MyApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

#### 2.3 创建定时任务

在方法上添加 `@Scheduled` 注解来定义定时任务：

```
@Component
public class MyTask {
    
    // 每5秒执行一次
    @Scheduled(fixedRate = 5000)
    public void task1() {
        System.out.println("固定速率任务执行: " + new Date());
    }
    
    // 方法执行完成后，延迟3秒再次执行
    @Scheduled(fixedDelay = 3000)
    public void task2() {
        System.out.println("固定延迟任务执行: " + new Date());
    }
    
    // 使用cron表达式
    @Scheduled(cron = "0/10 * * * * ?")
    public void task3() {
        System.out.println("cron表达式任务执行: " + new Date());
    }
}
```

### 3.Cron 表达式

Crontab工具 - 在线Cron表达式解析器 | 在线工具集](https://tooltool.net/zh/crontab)

| 字段                   | 允许值          | 允许的特殊字符  | 说明                                   |
| :--------------------- | :-------------- | :-------------- | :------------------------------------- |
| **秒（Seconds）**      | 0-59            | `, - * /`       | 每分钟的第几秒执行                     |
| **分（Minutes）**      | 0-59            | `, - * /`       | 每小时的第几分钟执行                   |
| **小时（Hours）**      | 0-23            | `, - * /`       | 每天的第几小时执行                     |
| **日（Day of month）** | 1-31            | `, - * ? / L W` | 每月的第几天执行（注意与"周"字段冲突） |
| **月（Month）**        | 1-12 或 JAN-DEC | `, - * /`       | 每年的第几个月执行                     |
| **周（Day of week）**  | 1-7 或 SUN-SAT  | `, - * ? / L #` | 每周的第几天执行（1=周日，7=周六）     |
| **年（Year，可选）**   | 1970-2099       | `, - * /`       | 指定年份执行                           |

## Apache POI 

### 简介

Apache POI 是 Apache 软件基金会的开源项目，提供 Java 程序对 Microsoft Office 格式文件（如 Excel、Word、PowerPoint）的读写功能。

### 依赖配置

使用 Maven 添加依赖：

```xml
<dependency>
    <groupId>org.apache.poi</groupId>
    <artifactId>poi-ooxml</artifactId>
    <version>5.2.3</version> <!-- 使用最新版本 -->
</dependency>
```

### 写入 Excel 文件 (XLSX 格式)

```java
@Test
public void writeExcel() throws IOException {
    // 1. 创建工作簿 (XSSF用于xlsx格式，HSSF用于xls格式)
    XSSFWorkbook workbook = new XSSFWorkbook();
    
    try {
        // 2. 创建工作表
        XSSFSheet sheet = workbook.createSheet("员工信息表");
        
        // 3. 创建标题行 (第0行)
        XSSFRow headerRow = sheet.createRow(0);
        headerRow.createCell(0).setCellValue("序号");
        headerRow.createCell(1).setCellValue("姓名");
        headerRow.createCell(2).setCellValue("性别");
        headerRow.createCell(3).setCellValue("年龄");
        
        // 4. 创建数据行 (第1行)
        XSSFRow dataRow = sheet.createRow(1);
        dataRow.createCell(0).setCellValue(1);
        dataRow.createCell(1).setCellValue("张三");
        dataRow.createCell(2).setCellValue("男");
        dataRow.createCell(3).setCellValue(28);
        
        // 5. 自动调整列宽
        for (int i = 0; i < 4; i++) {
            sheet.autoSizeColumn(i);
        }
        
        // 6. 写入文件
        FileOutputStream out = new FileOutputStream("员工信息表.xlsx");//文件的路径
        workbook.write(out);
        
        System.out.println("Excel文件写入成功");
    } finally {
        // 7. 关闭资源
        if (workbook != null) {
            workbook.close();
        }
    }
}
```

### 读取 Excel 文件 (XLSX 格式)

```java
@Test
public void readExcel() throws IOException {
    // 1. 创建文件输入流
    FileInputStream fis = new FileInputStream("员工信息表.xlsx");//文件的路径
    
    // 2. 创建工作簿
    XSSFWorkbook workbook = new XSSFWorkbook(fis);
    
    try {
        // 3. 获取第一个工作表
        XSSFSheet sheet = workbook.getSheetAt(0);
        
        // 4. 获取最后一行编号
        int lastRowNum = sheet.getLastRowNum();
        
        System.out.println("开始读取Excel数据...");
        
        // 5. 遍历行 (跳过标题行)
        for (int i = 1; i <= lastRowNum; i++) {
            XSSFRow row = sheet.getRow(i);
            if (row == null) continue;
            
            // 6. 读取单元格数据
            int id = (int) row.getCell(0).getNumericCellValue();
            String name = row.getCell(1).getStringCellValue();
            String gender = row.getCell(2).getStringCellValue();
            int age = (int) row.getCell(3).getNumericCellValue();
            
            System.out.printf("ID: %d, 姓名: %s, 性别: %s, 年龄: %d%n", 
                            id, name, gender, age);
        }
    } finally {
        // 7. 关闭资源
        if (workbook != null) {
            workbook.close();
        }
        if (fis != null) {
            fis.close();
        }
    }
}
```

## 杂七杂八知识点

### 时间知识点

#### **LocalDate**

- **表示纯日期**（年、月、日），不包含时间和时区信息。

#### **LocalDateTime**

- **表示日期和时间**（年、月、日、时、分、秒、纳秒），但不包含时区信息。

#### **LocalDate.plusDays(long days)**

- **功能**：在当前日期（`LocalDate`）上增加指定的天数，返回一个新的 `LocalDate` 对象（原对象不可变）。

- **示例**：

  ```
  LocalDate date = LocalDate.of(2023, 10, 25); // 2023-10-25
  LocalDate newDate = date.plusDays(3);       // 增加3天 → 2023-10-28
  ```

- **注意事项**：

  - 如果天数为负数，则相当于减去天数。
  - 自动处理月份和年份的进位（如从 2023-12-31 加 1 天会变成 2024-01-01）。

补充：**LocalDateTime**类似

#### MIN和MAX

1. **`LocalDateTime.of(data, LocalTime.MIN)`**
   - `data` 是一个 `LocalDate` 对象，表示具体的日期（年-月-日）。
   - `LocalTime.MIN` 表示一天的最小时间，即 `00:00:00.000000000`（午夜）。
   - **结果**：`beginTime` 表示这一天的**开始时刻**（如 `2023-10-25T00:00:00`）。
2. **`LocalDateTime.of(data, LocalTime.MAX)`**
   - `LocalTime.MAX` 表示一天的最大时间，即 `23:59:59.999999999`（午夜前的最后一刻）。
   - **结果**：`endTime` 表示这一天的**结束时刻**（如 `2023-10-25T23:59:59.999999999`）。

### StringUtils.join()

`StringUtils.join()` 是 **Apache Commons Lang** 库提供的一个实用方法，主要用于将**集合或数组中的元素连接成一个字符串**，并用指定的分隔符隔开。它的核心作用是**简化字符串拼接操作**，比手动用循环或 `StringBuilder` 更简洁、更安全。

#### 1. 拼接字符串集合

```
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
String joined = StringUtils.join(names, " | "); // "Alice | Bob | Charlie"
```

#### 2. 拼接 `LocalDate` 集合

```
List<LocalDate> dates = Arrays.asList(
    LocalDate.of(2023, 1, 1),
    LocalDate.of(2023, 1, 2)
);
String result = StringUtils.join(dates, ","); // "2023-01-01,2023-01-02"
```

#### 3. 拼接数组

```
int[] numbers = {1, 2, 3};
String joined = StringUtils.join(numbers, ":"); // "1:2:3"
```

#### 4. 处理 `null` 输入

```
List<String> nullList = null;
String safeResult = StringUtils.join(nullList, ","); // ""（不会报错）
```

### 转义字符

在 MyBatis 的 XML 映射文件中，`&gt;` 和 `&lt;` 是 **XML 转义字符**，用于替代特殊符号 `>` 和 `<`。这是因为 XML 本身会将这些符号视为标签的一部分，直接使用会导致解析错误。

------

#### **转义字符的作用**

| 转义字符 | 实际字符 | 说明   |
| :------- | :------- | :----- |
| `&gt;`   | `>`      | 大于号 |
| `&lt;`   | `<`      | 小于号 |
| `&amp;`  | `&`      | 和号   |
| `&quot;` | `"`      | 双引号 |
| `&apos;` | `'`      | 单引号 |

### @ConfigurationProperties

`@ConfigurationProperties(prefix = "sky.wechat")` 是 Spring Boot 提供的一个注解，用于将配置文件中的属性绑定到 Java 对象上。下面是如何使用它来管理微信相关配置的完整指南：

#### 基本用法

1. **创建配置类**：

```java
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "sky.wechat")
@Data
public class WechatProperties {
    private String appId;
    private String appSecret;
    private String token;
    private String aesKey;
    
    // 省略getter和setter方法
}
```

1. **在 application.yml 或 application.properties 中添加配置**：

```java
sky:
  wechat:
    app-id: "你的微信AppID"
    app-secret: "你的微信AppSecret"
    token: "你的微信Token"
    aes-key: "你的微信EncodingAESKey"
```

### 枚举类（enum）

```java
enum Season {
    SPRING, SUMMER, AUTUMN, WINTER
}
```

- `values()`：返回所有枚举常量数组
- `valueOf(String name)`：根据常量名获取枚举对象
- `ordinal()`：返回枚举常量的下标（从0开始）

✅ **总结注意点**：

1. 构造方法必须是 `private`，不能手动创建对象。
2. 常量必须写在最前面。
3. 不能继承类，但能实现接口。
4. 普通方法必须是public

```java
enum Color {
    RED("红色", 1),
    GREEN("绿色", 2),
    BLUE("蓝色", 3);

    private String name;
    private int code;

    // 构造方法（必须是private）
    Color(String name, int code) {
        this.name = name;
        this.code = code;
    }

    public String getName() {
        return name;
    }
    public int getCode() {
        return code;
    }
}

public class EnumTest {
    public static void main(String[] args) {
        Color c = Color.RED;
        System.out.println(c.getName()); // 输出 红色
        System.out.println(c.getCode()); // 输出 1
    }
}

```

